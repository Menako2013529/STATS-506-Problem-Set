---
title: "STATS 506 PS 2"
author: "Jingyan Zhang"
format:
  html:
    code-fold: true
    code-summary: "Show the code"
    embed-resources: true
editor: visual
---

link to my GitHub repo: https://github.com/Menako2013529/STATS-506-Problem-Set

```{r}
library(roxygen2)
library(microbenchmark)
```

# Problem 1

## a.

I referred to code generated by ChatGPT.

Version 1:

```{r}
#' Play dice game using a loop
#' @param n number of dice to roll
#' @return total winnings
play_dice_loop <- function(n) {
  total_winnings <- -2 * n  # The cost to play is $2 per die
  for (i in 1:n) {
    roll <- sample(1:6, 1)
    if (roll == 3 || roll == 5) {
      total_winnings <- total_winnings + (2 * roll)
    }
  }
  return(total_winnings)
}
#play_dice_loop(10)
```

Version 2:

```{r}
#' Play dice game using vectorized functions
#' @param n number of dice to roll
#' @return total winnings
play_dice_vectorized <- function(n) {
  rolls <- sample(1:6, n, replace = TRUE)
  winnings <- ifelse(rolls == 3 | rolls == 5, 2 * rolls, 0)
  total_winnings <- sum(winnings) - 2 * n
  return(total_winnings)
}
#play_dice_vectorized(10)

```

Version 3:

```{r}
#' Play dice game using table() to collapse dice rolls
#' @param n number of dice to roll
#' @return total winnings
play_dice_table <- function(n) {
  rolls <- sample(1:6, n, replace = TRUE)
  roll_counts <- table(rolls)
  
  winnings_3 <- ifelse("3" %in% names(roll_counts), as.numeric(roll_counts["3"]) * 2 * 3, 0)
  winnings_5 <- ifelse("5" %in% names(roll_counts), as.numeric(roll_counts["5"]) * 2 * 5, 0)
  
  total_winnings <- winnings_3 + winnings_5 - 2 * n
  return(total_winnings)
}
#play_dice_table(10)

```

Version 4:

```{r}
#' Play dice game using sapply
#' @param n number of dice to roll
#' @return total winnings
play_dice_apply <- function(n) {
  rolls <- sample(1:6, n, replace = TRUE)
  winnings <- sapply(rolls, function(roll) {
    if (roll == 3 || roll == 5) {
      return(2 * roll)
    } else {
      return(0)
    }
  })
  total_winnings <- sum(winnings) - 2 * n
  return(total_winnings)
}
#play_dice_apply(10)
```

## b.

```{r}
# Testing Version 1: Loop
cat("Version 1: Loop\n")
cat("Input 3:\n")
print(play_dice_loop(3))
cat("Input 3000:\n")
print(play_dice_loop(3000))
```

```{r}
# Testing Version 2: Vectorized
cat("Version 2: Vectorized\n")
cat("Input 3:\n")
print(play_dice_vectorized(3))
cat("Input 3000:\n")
print(play_dice_vectorized(3000))
```

```{r}
# Testing Version 3: Table
cat("Version 3: Table\n")
cat("Input 3:\n")
print(play_dice_table(3))
cat("Input 3000:\n")
print(play_dice_table(3000))
```

```{r}
# Testing Version 4: Apply
cat("Version 4: Apply\n")
cat("Input 3:\n")
print(play_dice_apply(3))
cat("Input 3000:\n")
print(play_dice_apply(3000))
```

## c.

I wrote a function to play and compare if the results are identical using random seed to control the randomization.

```{r}
#' Play and compare different dice game implementations
#' @param n Number of dice to roll
#' @return A list with the results of each implementation and a boolean indicating if they are identical
compare_dice_versions <- function(n) {
  # Set the seed for reproducibility
  set.seed(123)
  result1 <- play_dice_loop(n)

  set.seed(123)
  result2 <- play_dice_vectorized(n)

  set.seed(123)
  result3 <- play_dice_table(n)

  set.seed(123)
  result4 <- play_dice_apply(n)

  # Check if all results are identical
  identical_results <- identical(result1, result2) && identical(result2, result3) && identical(result3, result4)

  return(list(
    result_loop = result1,
    result_vectorized = result2,
    result_table = result3,
    result_apply = result4,
    identical = identical_results
  ))
}
```

```{r}
compare_dice_versions(3)
compare_dice_versions(3000)
```

## d.

```{r}
#' Play and compare different dice game implementations with benchmarking
#' @param n Number of dice to roll
#' @return A list with the results of the microbenchmark comparisons
benchmark_dice_versions <- function(n) {
  # Perform benchmarking using microbenchmark
  results <- microbenchmark(
    loop = {
      set.seed(123)
      play_dice_loop(n)
    },
    vectorized = {
      set.seed(123)
      play_dice_vectorized(n)
    },
    table = {
      set.seed(123)
      play_dice_table(n)
    },
    apply = {
      set.seed(123)
      play_dice_apply(n)
    },
    times = 100 # Run each version 100 times
  )
  
  return(results)
}
```

Benchmark on 1000 dice rolls:

```{r}
# Example usage with low input (1,000 dice rolls)
benchmark_1000 <- benchmark_dice_versions(1000)
print(benchmark_1000)
boxplot(benchmark_1000)
```

Benchmark on 100,000 dice rolls:

```{r}
# Example usage with large input (100,000 dice rolls)
benchmark_100000 <- benchmark_dice_versions(100000)
print(benchmark_100000)
boxplot(benchmark_100000)
```

Based on the numerical and visualization results, it is clear that Version 2 has least running time while Version 1 has the most running time. And Version 3 ranked second fastest and Version 4 ranked third fastest. The rankings are same in these two Benchmarks with 1000 dice rolls and 100,000 dice rolls.

## e.

```{r}
#' Monte Carlo simulation for the dice game
#' @param n_trials number of trials
#' @param n_rolls_per_game number of dice rolls
#' @return Expectation of winnings for one dice roll
monte_carlo_dice <- function(n_trials, n_rolls_per_game) {
  results <- numeric(n_trials)
  
  for (i in 1:n_trials) {
    results[i] <- play_dice_vectorized(n_rolls_per_game) # choose V2 with least time
  }
  
  # Calculate average winnings per roll
  expectation <- mean(results)/n_rolls_per_game
  return(expectation)
}
```

```{r}
set.seed(123)
average_winnings <- monte_carlo_dice(10000, 100)
cat("Average winnings per roll: ", average_winnings, "\n")
```

From the simulation result, the average winnings per roll is not fair (not zero).

# Problem 2

## a.

```{r}
cars <- read.csv("cars.csv")
```

```{r}
colnames(cars) <- c("height", "length", "width",
                    "driveline", "engine_type", "engine_hybrid",
                    "forward_gears", "transmission", "city_mpg",
                    "fuel_type", "highway_mpg", "classification",
                    "ID", "make", "model_year", "year", "horsepower",
                    "torque")
```

## b.

```{r}
gasoline_cars <- cars[which(cars$fuel_type=="Gasoline"),]
```

## c.

```{r}
hist(gasoline_cars$highway_mpg, main = "Distribution of Highway Gas Mileage (Gasoline Cars)",
     xlab = "Highway MPG", col = "lightblue", breaks = 20)
```

From the histogram, there exist outliers above 50 that made the histogram right-skewed. Therefore, we decide to remove outliers.

```{r}
transformed_gasoline <- gasoline_cars[which(gasoline_cars$highway_mpg<50),]
hist(transformed_gasoline$highway_mpg, main = "Distribution of Highway MPG for transformed data",
     xlab = "Highway MPG", col = "lightblue", breaks = 30)
```

## d.

```{r}
transformed_gasoline$year <- as.factor(transformed_gasoline$year)

model <- lm(highway_mpg ~ torque + horsepower + length + width + height + year, data = transformed_gasoline)

summary(model)
```

From the model summary, it is clear that torque, horsepower and height are significant if we set the significant level as p-value \< 0.05. The negative coefficient suggests that higher torque values are associated with lower highway MPG. For each 1-unit increase in torque, the highway MPGdecreases by 0.05, holding horsepower, dimensions, and year constant.

## e.

```{r}
library(interactions)
```

```{r}
model_interaction <- lm(highway_mpg ~ torque * horsepower + length + width + height + year, data = transformed_gasoline)

summary(model_interaction)

```

I referred to ChatGPT and discussed with Siyuan Wu about how to generate the interaction plot.

```{r}
median_year <- median(as.numeric(as.character(transformed_gasoline$year)))
median_year
```

```{r}
interact_plot(model_interaction, pred = torque, modx = horsepower, 
              at = list(horsepower = c(100, 200, 300)), 
              plot.points = TRUE,
              main.title = "Interaction between Torque and Horsepower on Highway MPG",
              x.label = "Torque",
              y.label = "Highway MPG",
              legend.main = "Horsepower",
              modx.values = c(100, 200, 300),
              mod2.values = median_year) # Fixing the year at the median

```

I choose year 2011 as it is the median of years. From the plot with lines showing horsepower of 100, 200 and 300, the larger horsepower results in less steep slope, showing that for higher horsepower cars, the increase in torque will affect less in highway MPG.

## f.

I discussed with Siyuan Wu.

```{r}
transformed_gasoline$year2010=ifelse(transformed_gasoline$year==2010,1,0)
transformed_gasoline$year2011=ifelse(transformed_gasoline$year==2011,1,0)
transformed_gasoline$year2012=ifelse(transformed_gasoline$year==2012,1,0)

X<-as.matrix(cbind(rep(1,length(transformed_gasoline$torque)),
                   transformed_gasoline$torque,
                   transformed_gasoline$width,
                   transformed_gasoline$length,
                   transformed_gasoline$height,
                   transformed_gasoline$horsepower,
                   transformed_gasoline$year2010,
                   transformed_gasoline$year2011,
                   transformed_gasoline$year2012))
y<-as.matrix(transformed_gasoline$highway_mpg)
beta<-solve((t(X)%*%X))%*%t(X)%*%y
beta
```

```{r}
model$coefficients
```

Same value.
